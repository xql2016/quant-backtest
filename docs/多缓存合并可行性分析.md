# 多缓存合并功能 - 可行性分析

## 📋 需求场景

### 示例：
```
缓存A: 2025-01-01 ━━━━━━━━━━━━━━━━━━━━━━━ 2025-07-08
缓存B:                  2025-06-02 ━━━━━━━━━━━━━━━━━━━━━━━━━━ 2026-01-01
                                ↑ 重叠区域 ↑
查询：         2025-04-04 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 2025-12-31

理论上可以合并：
- 2025-04-04 ~ 2025-07-08 来自缓存A
- 2025-07-09 ~ 2025-12-31 来自缓存B
```

---

## ✅ 可行性分析

### 技术上完全可行

**实现思路：**
1. 查找所有可能覆盖查询范围的缓存
2. 按时间排序，检查是否能拼接成完整范围
3. 处理重叠部分（选择使用哪个缓存）
4. 读取并合并数据
5. 返回完整的数据

**伪代码：**
```python
def merge_caches(query_start, query_end):
    # 1. 找到所有相关缓存
    relevant_caches = find_caches_in_range(query_start, query_end)
    
    # 2. 排序并检查连续性
    sorted_caches = sort_by_start_date(relevant_caches)
    
    # 3. 验证能否覆盖
    if can_cover_range(sorted_caches, query_start, query_end):
        # 4. 读取并合并
        dataframes = []
        for cache in sorted_caches:
            df = load_cache(cache)
            # 过滤到需要的部分，避免重复
            filtered_df = filter_range(df, ...)
            dataframes.append(filtered_df)
        
        # 5. 合并
        merged_df = pd.concat(dataframes)
        return merged_df
    else:
        return None  # 无法完全覆盖
```

---

## ⚠️ 潜在的坑

### 1. 重叠数据处理 ⭐⭐⭐⭐⭐

**问题：**
```
缓存A: 2025-01-01 ~ 2025-07-08
缓存B: 2025-06-02 ~ 2026-01-01
重叠:  2025-06-02 ~ 2025-07-08 (37天)

问题：这37天的数据应该用哪个缓存的？
```

**方案：**
- **方案1（推荐）**：使用最新缓存的数据
  - 优点：数据更新，更可能准确
  - 实现：按 `created_at` 排序，后创建的优先
  
- **方案2**：使用覆盖范围更大的缓存
  - 优点：数据一致性更好
  - 实现：选择 `(end_date - start_date)` 更大的

- **方案3**：使用访问次数更多的缓存
  - 优点：信任度更高
  - 实现：选择 `access_count` 更大的

**代码示例：**
```python
# 处理重叠
if overlap_exists:
    # 方案1：使用最新的
    preferred_cache = max(overlapping_caches, key=lambda x: x['created_at'])
    
    # 切分边界
    cache_a_data = cache_a[cache_a.index < overlap_start]
    cache_b_data = cache_b[cache_b.index >= overlap_start]
    
    merged = pd.concat([cache_a_data, cache_b_data])
```

---

### 2. 数据缺口检测 ⭐⭐⭐⭐⭐

**问题：**
```
缓存A: 2025-01-01 ~ 2025-05-31
缓存B: 2025-06-02 ~ 2026-01-01
缺口:  2025-06-01 (1天缺失！)

查询: 2025-04-01 ~ 2025-08-31
结果: 无法完全覆盖，合并失败
```

**检测逻辑：**
```python
def check_continuity(sorted_caches, query_start, query_end):
    # 检查第一个缓存是否覆盖起点
    if sorted_caches[0]['start_date'] > query_start:
        return False  # 起点缺失
    
    # 检查相邻缓存之间是否连续
    for i in range(len(sorted_caches) - 1):
        current_end = sorted_caches[i]['end_date']
        next_start = sorted_caches[i + 1]['start_date']
        
        # 检查缺口（允许重叠，不允许缺口）
        if next_start > current_end + timedelta(days=1):
            return False  # 存在缺口
    
    # 检查最后一个缓存是否覆盖终点
    if sorted_caches[-1]['end_date'] < query_end:
        return False  # 终点缺失
    
    return True  # 连续
```

---

### 3. 数据一致性问题 ⭐⭐⭐⭐

**问题：**
```
场景1：前复权因子变化
  - 缓存A (2025-01-01创建): 股价 10.00 (复权因子 1.0)
  - 缓存B (2025-06-01创建): 股价 10.50 (复权因子 1.05, 中间有分红)
  - 合并后: 两段数据的基准不同，可能出现异常跳跃

场景2：数据修正
  - 缓存A: 2025-03-15 的价格是 20.00
  - 缓存B: 包含修正后的 2025-03-15，价格变成 19.95
  - 重叠部分: 数据不一致

场景3：交易日历
  - 缓存A: 包含某个被事后取消的交易日
  - 缓存B: 不包含该交易日
  - 合并后: 日期索引可能重复或缺失
```

**影响：**
- 回测结果可能不准确
- 技术指标计算异常（如均线、MACD）
- 可能出现"未来数据"问题

---

### 4. 性能问题 ⭐⭐⭐

**问题：**
```
单缓存读取: 0.05秒
多缓存读取: 0.05秒 × N个缓存
合并操作:   0.02秒 × (N-1)次
总耗时:     约 0.05N + 0.02(N-1) 秒

示例：
- 2个缓存合并: 约 0.12秒 (仍然很快)
- 5个缓存合并: 约 0.33秒 (可接受)
- 10个缓存合并: 约 0.68秒 (开始变慢)
```

**优化方案：**
- 优先选择最少缓存数量的组合
- 限制最大合并缓存数（如 ≤ 3个）

---

### 5. 复杂度爆炸 ⭐⭐⭐

**问题：**
```
场景：同一个资产有多个部分重叠的缓存

缓存A: 2025-01-01 ~ 2025-06-30
缓存B: 2025-03-01 ~ 2025-09-30
缓存C: 2025-06-01 ~ 2025-12-31
缓存D: 2025-01-01 ~ 2025-12-31

查询: 2025-02-01 ~ 2025-11-30

可能的组合：
1. A + B + C (3个缓存)
2. A + C (2个缓存)
3. B + C (2个缓存)
4. D (1个缓存) ← 最优

问题：如何选择最优组合？
```

**策略：**
1. **优先单缓存**（最快）
2. **次优最少缓存数**
3. **最后考虑多缓存合并**

**算法：**
```python
def find_best_cache_combination(query_start, query_end):
    # 1. 尝试单缓存完全覆盖（已实现）
    single = find_single_covering_cache(...)
    if single:
        return [single]  # 最优
    
    # 2. 尝试两个缓存合并
    pairs = find_two_cache_combinations(...)
    if pairs:
        return min(pairs, key=lambda x: len(x))  # 选最少的
    
    # 3. 尝试多个缓存合并（可选，复杂度高）
    # 使用动态规划或贪心算法
    multiple = find_multiple_cache_combinations(...)
    if multiple:
        return min(multiple, key=lambda x: len(x))
    
    return None  # 无法覆盖
```

---

### 6. 边界情况 ⭐⭐

**情况1：完全重叠**
```
缓存A: 2025-01-01 ~ 2025-12-31
缓存B: 2025-01-01 ~ 2025-12-31
查询:  2025-01-01 ~ 2025-12-31

问题：选哪个？
答案：选最新的或访问次数多的
```

**情况2：微小缺口**
```
缓存A: 2025-01-01 ~ 2025-06-30
缓存B: 2025-07-02 ~ 2025-12-31
缺口:  2025-07-01 (1天)

问题：是否允许合并？
答案1：严格模式，不允许（推荐）
答案2：宽松模式，允许并标记缺失
```

**情况3：过期缓存**
```
缓存A: 2025-01-01 ~ 2025-06-30 (已过期)
缓存B: 2025-06-01 ~ 2025-12-31 (有效)

问题：是否使用过期缓存？
答案：不使用，只用有效缓存
```

---

### 7. 数据质量验证 ⭐⭐⭐

**需要检查：**
```python
def validate_merged_data(merged_df):
    # 1. 检查日期连续性
    date_diff = merged_df.index.to_series().diff()
    gaps = date_diff[date_diff > pd.Timedelta(days=3)]  # 允许周末
    if not gaps.empty:
        warning("存在日期缺口")
    
    # 2. 检查价格异常跳跃
    price_change = merged_df['close'].pct_change()
    outliers = price_change[abs(price_change) > 0.2]  # 单日涨跌超20%
    if not outliers.empty:
        warning("存在价格异常跳跃")
    
    # 3. 检查重复日期
    duplicates = merged_df.index.duplicated()
    if duplicates.any():
        error("存在重复日期")
        merged_df = merged_df[~duplicates]  # 去重
    
    return merged_df
```

---

## 💡 推荐实现方案

### 阶段性实现

#### 阶段1：单缓存覆盖（已实现✅）
```python
缓存A: 2025-01-01 ~ 2025-12-31
查询:  2025-03-01 ~ 2025-06-30
结果:  使用缓存A，过滤数据
```

#### 阶段2：两个缓存合并（推荐实现）
```python
缓存A: 2025-01-01 ~ 2025-07-08
缓存B: 2025-06-02 ~ 2026-01-01
查询:  2025-04-04 ~ 2025-12-31
结果:  合并A和B，处理重叠部分

条件：
- 最多2个缓存
- 必须连续（可重叠，不可缺口）
- 重叠部分使用最新缓存的数据
```

#### 阶段3：多缓存合并（可选）
```python
缓存A/B/C: 多个部分重叠的缓存
查询:  任意范围
结果:  智能选择最优组合

复杂度高，收益有限，可以暂不实现
```

---

## 🎯 具体实现建议

### 建议的优先级：

**优先实现（收益高，风险低）：**
1. ✅ 单缓存完全覆盖（已实现）
2. ⭐ **两个连续缓存合并**
   - 场景：缓存A到6月，缓存B从6月开始
   - 风险：低（只需处理一个边界）
   - 收益：高（很常见的场景）

**可选实现（收益中，风险高）：**
3. 两个重叠缓存合并
   - 场景：你提到的场景
   - 风险：中（需要处理重叠）
   - 收益：中（不如连续常见）

**暂不实现（收益低，复杂度高）：**
4. 多个缓存合并（>2个）
   - 复杂度高
   - 实际场景少
   - 性能可能变差

---

## 📊 实现难度评估

| 功能 | 难度 | 代码量 | 风险 | 推荐 |
|------|------|---------|------|------|
| 单缓存覆盖 | ⭐ | 50行 | 低 | ✅ 已实现 |
| 两缓存连续合并 | ⭐⭐ | 100行 | 低 | ⭐ 推荐 |
| 两缓存重叠合并 | ⭐⭐⭐ | 150行 | 中 | 可选 |
| 多缓存合并 | ⭐⭐⭐⭐⭐ | 300行+ | 高 | 不推荐 |

---

## 🔍 关键坑点总结

### 必须处理的坑（★★★★★）：
1. **数据缺口检测** - 必须严格检查
2. **重叠数据选择** - 需要明确策略
3. **日期连续性验证** - 避免断档

### 需要注意的坑（★★★）：
4. **数据一致性** - 可以通过校验缓解
5. **性能优化** - 限制缓存数量
6. **边界情况** - 详细测试

### 可以接受的坑（★）：
7. **复杂度** - 通过限制场景简化

---

## 💡 我的建议

**现阶段：**
- ✅ 保持当前单缓存覆盖的实现
- ⏸️ 暂不实现多缓存合并

**原因：**
1. 单缓存覆盖已经解决了80%的场景
2. 多缓存合并复杂度高，收益有限
3. 数据一致性风险较大

**如果要实现：**
- 建议从"两个连续缓存"开始
- 严格模式：不允许缺口
- 重叠部分：使用最新缓存
- 限制：最多合并2-3个缓存

**最佳实践：**
```
建议用户策略：
1. 尽量缓存大范围数据（如全年）
2. 避免创建多个小范围缓存
3. 定期清理冗余缓存
```

---

**结论：** 技术上可行，但建议谨慎实现。如果真要做，先做两缓存连续合并，严格控制边界条件。

---

**日期**: 2026-02-13  
**状态**: 📋 需求分析完成，待决策
